<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Hindi Caption Maker (.ass) — with Effect Preview</title>
<style>
  :root { --bg:#0f172a; --card:#111827; --text:#e5e7eb }
  *{box-sizing:border-box;font-family:system-ui,Segoe UI,Roboto,Inter,"Rozha One Regular",sans-serif}
  body{margin:0;background:var(--bg);color:var(--text)}
  header{padding:12px 16px;border-bottom:1px solid #1f2937;font-weight:600}
  .wrap{display:grid;grid-template-columns:380px 1fr;height:calc(100vh - 52px)}
  .panel{overflow:auto;padding:14px;background:var(--card)}
  .section{border:1px solid #1f2937;border-radius:12px;padding:12px;margin-bottom:12px}
  .row{display:grid;grid-template-columns: 1fr 1fr; gap:8px}
  label{font-size:12px;color:#cbd5e1}
  input,select,textarea{width:100%;padding:8px;border:1px solid #374151;border-radius:8px;background:#0b1220;color:#e5e7eb}
  textarea{min-height:120px;font-family:ui-monospace,Menlo,monospace}
  button{background:#2563eb;border:none;color:white;padding:10px 12px;border-radius:10px;cursor:pointer}
  button.secondary{background:#374151}
  .preview{position:relative;background:#000;height:100%;display:flex;align-items:center;justify-content:center}
  video{max-width:100%;max-height:100%}
  #capOverlay{position:absolute;inset:0;pointer-events:none}
  .capLine{position:absolute;white-space:pre-wrap;text-align:center}
  .capText{display:inline-block; will-change: transform, opacity, filter, clip-path, max-width}
  .tiny{font-size:11px;color:#94a3b8}
  .kbd{font-family:ui-monospace,monospace;background:#0b1220;border:1px solid #334155;border-radius:6px;padding:2px 6px}
</style>
</head>
<body>
<header>Hindi Caption Maker — preview + export .ass (with effects)</header>
<div class="wrap">
  <div class="panel">
    <div class="section">
      <div class="row">
        <div>
          <label>Load video (for preview)</label>
          <input type="file" id="videoFile" accept="video/*">
        </div>
        <div>
          <label>Resolution (PlayResX × PlayResY)</label>
          <div class="row">
            <input id="resX" type="number" value="1920" min="320">
            <input id="resY" type="number" value="1080" min="240">
          </div>
        </div>
      </div>

      <div class="row">
        <div>
          <label>Font family</label>
          <input id="fontFamily" value="Rozha One Regular">
        </div>
        <div>
          <label>Font size</label>
          <input id="fontSize" type="number" value="90" min="8">
        </div>
      </div>

      <div class="row">
        <div>
          <label>Text color</label>
          <input id="colorText" type="color" value="#bcf425">
        </div>
        <div>
          <label>Opacity (0=solid, 255=transparent)</label>
          <input id="alphaText" type="number" value="0" min="0" max="255">
        </div>
      </div>

      <div class="row">
        <div>
          <label>Outline color</label>
          <input id="colorOutline" type="color" value="#000000">
        </div>
        <div>
          <label>Outline thickness</label>
          <input id="outline" type="number" value="0" min="0" step="1">
        </div>
      </div>

      <div class="row">
        <div>
          <label>Shadow</label>
          <input id="shadow" type="number" value="3" min="0" step="1">
        </div>
        <div>
          <label>Wrap style</label>
          <select id="wrapStyle">
            <option value="2" selected>Smart (2)</option>
            <option value="1">No word wrap (1)</option>
            <option value="3">Smart wider last line (3)</option>
            <option value="0">EOL only (0)</option>
          </select>
        </div>
      </div>

      <div class="row">
        <div>
          <label>Position preset</label>
          <select id="align">
            <option value="2">Center Bottom (2)</option>
            <option value="8">Center Top (8)</option>
            <option value="5">Center Middle (5)</option>
            <option value="1">Left Bottom (1)</option>
            <option value="3">Right Bottom (3)</option>
            <option value="4" selected>Left Middle (4)</option>
            <option value="6">Right Middle (6)</option>
            <option value="7">Left Top (7)</option>
            <option value="9">Right Top (9)</option>
          </select>
        </div>
        <div>
          <label>Margins (L / R / V px)</label>
          <div class="row">
            <input id="marginL" type="number" value="80" min="0">
            <input id="marginR" type="number" value="80" min="0">
            <input id="marginV" type="number" value="60" min="0">
          </div>
        </div>
      </div>

      <div class="row">
        <div>
          <label>Disable wrapping (single line)</label>
          <select id="singleLine">
            <option value="0" selected>No</option>
            <option value="1">Yes ({\q1})</option>
          </select>
        </div>
        <div>
          <label>Reveal effect</label>
          <select id="effect">
            <option value="none">None</option>
            <option value="fade" selected>Fade (250ms in / 150ms out)</option>
            <option value="slideup">Slide Up (600ms)</option>
            <option value="glow">Soft Glow (600ms)</option>
            <option value="karaoke">Karaoke (line duration)</option>
          </select>
        </div>
      </div>
    </div>

    <div class="section">
      <label>Captions (one per line): <span class="tiny">Format: <span class="kbd">HH:MM:SS.mmm → HH:MM:SS.mmm | Your Hindi text (\N for line breaks)</span></span></label>
      <textarea id="lines" placeholder="00:00:01.000 → 00:00:05.000 | ॐ गं गणपतये नमः ॥&#10;00:00:06.000 → 00:00:10.000 | वक्रतुंड महाकाय \N सूर्यकोटि समप्रभ"></textarea>
      <div class="row" style="margin-top:8px">
        <button id="previewBtn">Preview</button>
        <button id="exportBtn" class="secondary">Export .ass</button>
      </div>
    </div>

    <div class="section">
      <b>Tips</b>
      <ul class="tiny">
        <li>Use <span class="kbd">\N</span> for manual line breaks.</li>
        <li>“Single line” adds <span class="kbd">{\q1}</span> on export and uses <i>nowrap</i> in preview.</li>
        <li>Exact pixel placement: put <span class="kbd">{\pos(x,y)}</span> at start of text (applies in export).</li>
        <li>Burn: <span class="kbd">ffmpeg -i input.mp4 -vf "ass=captions.ass" -c:a copy out.mp4</span></li>
      </ul>
    </div>
  </div>

  <div class="preview">
    <video id="vid" controls></video>
    <div id="capOverlay"></div>
  </div>
</div>

<script>
const $ = id => document.getElementById(id);
const hhmmToSec = s => { const m=s.trim().match(/^(\d{2}):(\d{2}):(\d{2})(?:[.,](\d{1,3}))?$/); if(!m) return null; const [_,H,M,S,ms='0']=m; return (+H)*3600+(+M)*60+(+S)+(+ms)/1000; };
const secToAss = t => { const cs=Math.round(t*100); const H=Math.floor(cs/360000); const M=Math.floor((cs%360000)/6000); const S=Math.floor((cs%6000)/100); const C=cs%100; return `${H}:${String(M).padStart(2,'0')}:${String(S).padStart(2,'0')}.${String(C).padStart(2,'0')}`; };
const cssHexToASS = (hex, alpha=0) => { const h=hex.replace('#',''); const r=h.slice(0,2),g=h.slice(2,4),b=h.slice(4,6); const AA=Number(alpha).toString(16).toUpperCase().padStart(2,'0'); return `&H${AA}${b.toUpperCase()}${g.toUpperCase()}${r.toUpperCase()}`; };
function parseLines(raw){
  const rows=[]; raw.split(/\r?\n/).forEach(line=>{
    if(!line.trim()) return;
    const m=line.split('|'); if(m.length<2) return;
    const times=m[0].split('→'); if(times.length<2) return;
    const start=hhmmToSec(times[0].trim()), end=hhmmToSec(times[1].trim());
    const text=m.slice(1).join('|').trim(); if(start==null||end==null||!text) return;
    rows.push({start,end,text});
  }); return rows;
}

$('videoFile').addEventListener('change', e=>{
  const f=e.target.files?.[0]; if(!f) return;
  $('vid').src = URL.createObjectURL(f);
});

function currentStyle(){
  return {
    fam: $('fontFamily').value,
    fs: +$('fontSize').value||64,
    color: $('colorText').value,
    outline: +$('outline').value||0,
    shadow: +$('shadow').value||0,
    align: +$('align').value||2,
    mL: +$('marginL').value||0,
    mR: +$('marginR').value||0,
    mV: +$('marginV').value||0,
    single: $('singleLine').value==='1',
    effect: $('effect').value
  };
}

function place(el, align, mL, mR, mV){
  // Map ASS alignment to CSS position
  const map = {
    1:{x:'left',y:'bottom'},2:{x:'center',y:'bottom'},3:{x:'right',y:'bottom'},
    4:{x:'left',y:'middle'},5:{x:'center',y:'middle'},6:{x:'right',y:'middle'},
    7:{x:'left',y:'top'},   8:{x:'center',y:'top'},   9:{x:'right',y:'top'}
  }[align];
  if(map.x==='left'){ el.style.left = mL+'px'; el.style.right='auto'; el.style.transform='translateX(0)'; el.style.textAlign='left'; }
  if(map.x==='center'){ el.style.left = '50%'; el.style.right='auto'; el.style.transform='translateX(-50%)'; el.style.textAlign='center'; }
  if(map.x==='right'){ el.style.right = mR+'px'; el.style.left='auto'; el.style.transform='translateX(0)'; el.style.textAlign='right'; }
  if(map.y==='top'){ el.style.top = mV+'px'; el.style.bottom='auto'; }
  if(map.y==='middle'){ el.style.top='50%'; el.style.bottom='auto'; el.style.transform += ' translateY(-50%)'; }
  if(map.y==='bottom'){ el.style.bottom = mV+'px'; el.style.top='auto'; }
}

function applyPreview(){
  const rows=parseLines($('lines').value);
  const ov=$('capOverlay'); ov.innerHTML='';
  const st=currentStyle();

  rows.forEach(r=>{
    const outer=document.createElement('div'); outer.className='capLine';
    place(outer, st.align, st.mL, st.mR, st.mV);
    outer.dataset.start=r.start; outer.dataset.end=r.end;
    outer.style.fontFamily=st.fam; outer.style.fontSize=st.fs+'px';
    outer.style.color=st.color;
    outer.style.whiteSpace= st.single ? 'nowrap' : 'pre-wrap';
    outer.style.filter = `drop-shadow(0 0 ${st.shadow}px rgba(0,0,0,0.8))`;
    outer.style.webkitTextStroke = st.outline>0? `${Math.max(1,st.outline/2)}px ${$('colorOutline').value}`:'';

    const inner=document.createElement('span'); inner.className='capText';
    inner.textContent = r.text.replace(/\\N/g, '\n');
    outer.appendChild(inner);
    ov.appendChild(outer);
  });

  const FADE_IN=250, FADE_OUT=150, SLIDE_MS=600, GLOW_MS=600;

  function tick(){
    const t=$('vid').currentTime||0;
    [...ov.children].forEach(outer=>{
      const s=+outer.dataset.start, e=+outer.dataset.end, d=(e-s);
      const inner=outer.firstChild;
      const visible = t>=s && t<=e;
      outer.style.display = visible ? 'block':'none';
      if(!visible) return;

      // base styles
      inner.style.opacity = 1;
      inner.style.transform = 'translateY(0px)';
      inner.style.filter = `drop-shadow(0 0 ${st.shadow}px rgba(0,0,0,0.8))`;

      // EFFECTS
      switch(st.effect){
        case 'fade': {
          let op=1;
          if(t<s+FADE_IN/1000) op = Math.max(0, Math.min(1, (t-s)/(FADE_IN/1000)));
          if(t>e-FADE_OUT/1000) op = Math.max(0, Math.min(op, (e-t)/(FADE_OUT/1000)));
          inner.style.opacity = op;
          break;
        }
        case 'slideup': {
          const p = Math.max(0, Math.min(1, (t-s)/(SLIDE_MS/1000)));
          const y = (1-p)*40; // px
          const op = p;
          inner.style.transform = `translateY(${y}px)`;
          inner.style.opacity = op;
          break;
        }
        case 'glow': {
          const p = Math.max(0, Math.min(1, (t-s)/(GLOW_MS/1000)));
          const blur = (1-p)*4 + 2; // px
          inner.style.filter = `drop-shadow(0 0 ${blur}px rgba(0,0,0,0.9))`;
          break;
        }
        case 'karaoke': {
          const words = r.text.replace(/\\N/g, ' ').split(' ');
          const wordDur = d / words.length;
          let currentWidth = 0;
          let revealWidth = 0;
          
          if (!outer.dataset.wordWidths) {
              const span = document.createElement('span');
              span.style.fontFamily = st.fam;
              span.style.fontSize = st.fs + 'px';
              span.style.position = 'absolute';
              span.style.visibility = 'hidden';
              document.body.appendChild(span);

              const widths = words.map(word => {
                  span.textContent = word;
                  return span.offsetWidth;
              });
              outer.dataset.wordWidths = JSON.stringify(widths);
              document.body.removeChild(span);
          }
          const wordWidths = JSON.parse(outer.dataset.wordWidths);
          
          for (let i = 0; i < words.length; i++) {
              if (t >= s + i * wordDur) {
                  currentWidth += wordWidths[i];
              }
          }
          inner.style.clipPath = `polygon(0 0, ${currentWidth}px 0, ${currentWidth}px 100%, 0 100%)`;
          break;
        }
      }
    });
    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);
}

$('previewBtn').addEventListener('click', applyPreview);





function exportASS(){
  try{
    const rows = parseLines($('lines').value);
    if(!rows.length){ alert('Add at least one caption line.'); return; }

    const PlayResX = +$('resX').value || 1920;
    const PlayResY = +$('resY').value || 1080;
    const WrapStyle = +$('wrapStyle').value || 2;

    const font = $('fontFamily').value || 'Rozha One Regular';
    const fontsize = +$('fontSize').value || 80;

    const pri  = cssHexToASS($('colorText').value, $('alphaText').value || 0);
    const out  = cssHexToASS($('colorOutline').value, 0);
    const back = '&H64000000';
    const sec  = '&H000000FF';

    const outlinePx = +$('outline').value || 0;
    const shadowPx  = +$('shadow').value  || 5;

    const alignVal = +$('align').value || 2;
    const mL = +$('marginL').value || 80;
    const mR = +$('marginR').value || 80;
    const mV = +$('marginV').value || 60;

    const single = ($('singleLine').value === '1');
    const effectSel = $('effect').value;

    // anchor from alignment + margins
    function anchorXY(a){
      switch(a){
        case 1: return {x:mL,               y:PlayResY - mV};      // Left-Bottom
        case 2: return {x:PlayResX/2,       y:PlayResY - mV};      // Center-Bottom
        case 3: return {x:PlayResX - mR,    y:PlayResY - mV};      // Right-Bottom
        case 4: return {x:mL,               y:PlayResY/2};         // Left-Middle
        case 5: return {x:PlayResX/2,       y:PlayResY/2};         // Center-Middle
        case 6: return {x:PlayResX - mR,    y:PlayResY/2};         // Right-Middle
        case 7: return {x:mL,               y:mV};                 // Left-Top
        case 8: return {x:PlayResX/2,       y:mV};                 // Center-Top
        case 9: return {x:PlayResX - mR,    y:mV};                 // Right-Top
        default:return {x:PlayResX/2,       y:PlayResY - mV};
      }
    }

    // compose a single override block with an+q1 and (optional) effect
    function effectTag(a){
      const {x,y} = anchorXY(a);
      const base = single ? `{\\q1\\an${a}` : `{\\an${a}`;
      if(effectSel === 'fade')     return `${base}\\fad(250,150)}`;
      if(effectSel === 'glow')     return `${base}\\t(0,600,\\bord${outlinePx+2}\\shad${shadowPx+2})\\t(600,900,\\bord${outlinePx}\\shad${shadowPx})}`;
      if(effectSel === 'slideup'){ // vertical move into place
        const offset = (a===7||a===8||a===9) ? -120 : 120; // if top, slide down; else slide up
        return `${base}\\move(${Math.round(x)},${Math.round(y+offset)},${Math.round(x)},${Math.round(y)},0,600)}`;
      }
      return `${base}}`; // none
    }

    function karaokeText(a, text, durSec){
      const base = single ? `{\\q1\\an${a}}` : `{\\an${a}}`;
      const words = text.replace(/\\N/g,' ').trim().split(/\s+/).filter(Boolean);
      const totalCs = Math.max(1, Math.round(durSec*100));
      const per = Math.max(1, Math.round(totalCs / Math.max(1, words.length)));
      return base + words.map(w => `{\\k${per}}${w}`).join(' ');
    }

    const header = `[Script Info]
Title: Hindi Captions
ScriptType: v4.00+
PlayResX: ${PlayResX}
PlayResY: ${PlayResY}
WrapStyle: ${WrapStyle}
ScaledBorderAndShadow: yes

[V4+ Styles]
; Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: HindiStyle,${font},${fontsize},${pri},${sec},${out},${back},1,0,0,0,100,100,0,0,1,${outlinePx},${shadowPx},${alignVal},${mL},${mR},${mV},1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
`;

    const events = rows.map(r=>{
      const dur = r.end - r.start;
      const text = r.text; // keep \N as real line breaks
      const payload = (effectSel === 'karaoke')
        ? karaokeText(alignVal, text, dur)
        : effectTag(alignVal) + text;
      return `Dialogue: 0,${secToAss(r.start)},${secToAss(r.end)},HindiStyle,,0,0,0,,${payload}`;
    }).join('\n');

    const ass = header + events + '\n';

    const blob = new Blob([ass], {type:'text/plain;charset=utf-8'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'captions.ass';
    document.body.appendChild(a);
    a.click();
    setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 200);
  }catch(e){ console.error(e); alert('Export failed. See console.'); }
}



$('exportBtn').addEventListener('click', exportASS);
</script>

</body>
</html>